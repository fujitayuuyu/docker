# Dockerの構文構成
Docker の構文は、主に次の 4 つのグループに分類できるよ。
* コンテナの実行
* コンテナの管理と検査
* Dockerイメージの管理
* Dockerデーモンの統計と情報

## Dockerイメージの管理
### Dockerイメージのダウンロード
Dockerを動かすためには、そもそもコンテナとして使用するイメージファイルが必要なんだー。
だから、「docker pull」コマンドを利用して、任意のdockerイメージをダウンロードする必要があるんだ。

* コマンドのテンプレ
> `docker pull $IMAGE`　(バージョン指定なし)
> `docker pull $IMAGE:$VERSION`　(バージョン指定あり)

* コマンドの使用例
> `docker pull ubuntu`　(バージョン指定なし)
> `docker pull ubuntu:22.04`　(バージョン指定あり)

`$IMAGE`には、apacheやnginx、ubuntu、bind9,gobusterなどのサービスのイメージを指定するよ。
バージョン指定をしなければ、最新バージョンのイメージがダウンロードされるよ。

### Dockerイメージの操作(ls,rm)
Dockerで管理しているイメージを操作するために「docker image」コマンドを利用するよ。

* 保存されているイメージの一覧を表示
> `docker image ls`

* 保存されているイメージの削除
> `docker image rm $REPOSITORY`

## コンテナの管理
コンテナは、実際に、内部で動くサービスだよ。こいつを管理することが結構、ラクなんだ。
### Dockerのコンテナ実行
> `docker run [OPTIONS] $IMAGE_NAME [COMMAND] [ARGUMENTS...]` 

### docker runのオプション
| オプション    | 説明                                                                                                                                                     | 関連するDockerfileの指示 | 例                                |
|--------------|----------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------|-----------------------------------|
| -d           | この引数は、コンテナを「デタッチ」モードで起動するように指示します。つまり、コンテナはバックグラウンドで実行されます。                                     | 該当なし                  | `docker run -d helloworld`      |
| -it          | この引数には 2 つの部分があります。「i」は対話的に実行することを意味し、「t」は Docker にコンテナ内でシェルを実行するように指示します。                   | 該当なし                  | `docker run -it helloworld`      |
| -v           | この引数は「Volume」の略で、Dockerにホストオペレーティングシステムからコンテナ内の場所にディレクトリまたはファイルをマウントするように指示します。         | マウントするパス           | `docker run -v /host/os/directory:/container/directory helloworld` |
| -p           | この引数は、Docker にホスト オペレーティング システム上のポートをコンテナー内で公開されているポートにバインドするように指示します。また、通信できるホストIPを指定することができる(例：127.0.0.1:80:80)| 公開するポート(公開ポート:内部ポート)   | `docker run -p 80:80 webserver`  |
| --rm         | この引数は、コンテナが指示された実行を完了したらコンテナを削除するように Docker に指示します。                                                              | 該当なし                  | `docker run --rm helloworld`     |
| --name       | この引数を使用すると、コンテナに分かりやすく覚えやすい名前を付けることができます。このオプションを使用せずにコンテナを実行すると、名前は 2 つのランダムな単語になります。 | 該当なし                  | `docker run --name helloworld`   |

## 実行中のコンテナの一覧表示
* 実行中のコンテナのみ表示
> `docker ps`

* 存在するコンテナをすべて表示(停止しているコンテナも含む)
> `docker ps -a`

# Dockerfileの基本
Dockerfile は Docker で重要な役割を果たすよ。Dockerfile はフォーマットされたテキスト ファイルで、基本的にはコンテナーが実行すべき操作マニュアルとして機能し、最終的に Docker イメージを組み立てるんだ。
コンテナの構築時にコンテナが実行するコマンドを格納するために使用するよ。
つまり、こいつを使えば、オリジナルのイメージを作れちゃうってわけ！！

* 参照：https://www.kagoya.jp/howto/cloud/container/dockercompose/
## Dockerfileの構文
設定ファイルみたいな感じの構文で結構そのままだよぉ

| Instruction | Description                                                                                                 | Example                             |
|-------------|-------------------------------------------------------------------------------------------------------------|-------------------------------------|
| FROM        | この命令は、コンテナのビルドステージを設定し、ベースイメージ（オペレーティングシステム）を設定します。すべてのDockerfileはこれから始まります。 | `FROM ubuntu`                       |
| RUN         | この命令は、新しいレイヤー内でコンテナ内のコマンドを実行します。                                | `RUN whoami`                       |
| COPY        | この命令は、ローカルシステムからコンテナ内の作業ディレクトリにファイルをコピーします（構文はcpコマンドに似ています）。 | `COPY /home/cmnatic/myfolder/app/` |
| WORKDIR     | この命令は、コンテナの作業ディレクトリを設定します。（Linuxでcdを使用するのと似ています。）              | `WORKDIR /`                        |
| CMD         | この命令は、コンテナが起動したときに実行されるコマンドを決定します（これを使用してサービスやアプリケーションを開始します）。 | `CMD /bin/sh -c script.sh`        |
| EXPOSE      | この命令は、コンテナを実行する際に公開すべきポートを知らせるために使用されます。 | `EXPOSE 80`（コンテナを実行する際にポート80を公開するよう指示します、つまり `docker run -p 80:80`） |

## Dockerfileを用いて、imageを作成
Dockerfileのあるディレクトリで実行する。
>docker build -t $IMAGE_NAME $DOKCKERFILE

# Docker Composeの基本
Docker Composeてのは、複数のコンテナ (またはアプリケーション) が、互いに独立して実行しながら、必要に応じて相互に操作できるようにするために使うよ！
多くの場合、アプリケーションを実行するには追加のサービスが必要ですが、これは単一のコンテナでは実行できません。たとえば、最新の動的な Web サイトでは、データベースや Web サーバーなどのサービスが使用されます。このタスクでは、各アプリケーションを「マイクロサービス」として考えるよ。

Docker Compose を使用すると、めっちゃ多い「マイクロサービス」を 1 つの単一の「サービス」にできるんだ！！

## Docker Compose使い方手順
1. Docker Compose がインストールするよ (デフォルトでは Docker に付属してない)。
2. docker-compose.ymlファイルを作るよ
3. Docker Compose を使用してコンテナを構築および管理するよ

## 重要な Docker Composeコマンド
| Command  | Explanation                                                                                          | Example                             |
|----------|------------------------------------------------------------------------------------------------------|-------------------------------------|
| up       | このコマンドは、コンポーズファイルで指定されたコンテナを（再）作成/ビルドして起動します。                      | `docker-compose up`                 |
| start    | このコマンドは、コンポーズファイルで指定されたコンテナを起動します（ただし、コンテナは既にビルドされている必要があります）。 | `docker-compose start`              |
| down     | このコマンドは、コンポーズファイルで指定されたコンテナを停止し、削除します。                                | `docker-compose down`               |
| stop     | このコマンドは、コンポーズファイルで指定されたコンテナを停止します（削除はしません）。                       | `docker-compose stop`               |
| build    | このコマンドは、コンポーズファイルで指定されたコンテナをビルドします（ただし、起動はしません）。               | `docker-compose build`              |

## docker-compose.ymlファイルの作成
1 つのファイルですべてを管理するんだ。YAML形式だからインデントが必要であることに注意しよう( 2 つのスペースを使用することをお勧めしますが、これは一貫している必要があるよ)。

※上から下に実行されるから、実行するコンテナの順序を考えてファイルを書こうね
### ファイルの構文
| Instruction              | Explanation                                                                                                               | Example                                      |
|-------------------------|---------------------------------------------------------------------------------------------------------------------------|----------------------------------------------|
| version                 | これはファイルの先頭に配置され、docker-compose.ymlがどのバージョンのCompose用に書かれているかを識別します。                        | `'3.3'`                                      |
| services                | この命令は、管理対象のコンテナの始まりを示します。                                                                           | `services:`                                  |
| name (replace value)    | この命令は、コンテナとその設定を定義する場所です。"name"は、実際に定義したいコンテナの名前（例： "webserver" または "database"）に置き換える必要があります。 | `webserver`                                  |
| build                   | この命令は、このコンテナ/サービスのDockerfileが含まれているディレクトリを定義します。（これを使うか、イメージを使う必要があります）。  | `./webserver`                                |
| ports                   | この命令は、公開するポートとバインドする内部ポートを指定するよ（これはイメージ/Dockerfileに依存します）。                                   | `'80:80'`                                    |
| volumes                 | この命令は、ホストオペレーティングシステムからコンテナにマウントされるべきディレクトリをリストします。                          | `'./home/cmnatic/webserver/:/var/www/html'` |
| environment             | この命令は、環境変数（安全ではない）を渡すために使用されます。例：パスワード、ユーザー名、タイムゾーン設定など。               | `MYSQL_ROOT_PASSWORD=helloworld`            |
| image                   | この命令は、コンテナがどのイメージで構築されるべきかを定義します。（これを使うか、buildを使う必要があります）。                 | `mysql:latest`                               |
| networks                | この命令は、コンテナが参加するネットワークを定義します。コンテナは複数のネットワークに参加できます（例：ウェブサーバーは一つのデータベースにしか接続できませんが、データベースは複数のウェブサーバーに接続できます）。 | `ecommerce`   |

# Dockerの通信(Docker ソケット)
## OSとコンテナ間の通信をどうやってるのー？
DockerクライアントとDocker サーバーがDockerをダウンロードしたときに入れられて、こいつらが、OSとコンテナ間の通信をやっているよ。これらは、ソケットAPIと同じようなものだよ。
IPC(プロセス間通信)っていう形でOSとコンテナ間は通信されているよ。だから、公開ポート(OS本体のポート)、内部ポート(プロセスのポート)が設定できるんだ、たぶん。

ちなみに、API 開発者ツールを使用して Docker サーバーと対話できるよ。だからこれを悪用して、Dockerのコンテナシステムやそいつを動かしているマシンに攻撃できる可能性があるよ。
